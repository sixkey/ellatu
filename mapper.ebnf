@@grammar::Mapper 
@@whitespace :: /[\t ]+/
  
document
    = 
    decls:{decl} $
    ; 

decl
    =
    | function
    | newline 
    ;

function::Function
    = 
    'fun' ~ name:name params:{name} ':' newline body:codeblock
    ; 

amn_function::AmnFunction
    =
    fun:function
    ; 

codeblock::Codeblock
    =
    '{' newline  lines:{stmt_line}+ '}' newline 
    ; 

stmt_line
    = 
    | @:if_stmt
    | @:while_stmt
    | @:stmt newline  
    | @:amn_function 
    ; 

if_stmt::IfStatement
    =
    'if' ~ cond:cond ':' newline body:codeblock 
    elifs:{elif_stmt}
    else_block:[else_stmt]
    ;

elif_stmt
    = 
    'elif' ~ cond:cond ':' newline body:codeblock 
    ; 

else_stmt
    =
    'else' ~ ':' newline @:codeblock
    ;

while_stmt::WhileStmt
    =
    'while' ~ cond:cond ':' newline body:codeblock
    ;

for_stmt::ForStmt
    = 
    'for' ~ name 'in' generator ':' newline body:codeblock 
    ; 

generator::Generator
    = 
    '[' from:int '...' to:int [(',' step:int)] ']'
    ; 

cond 
    =
    @:expression
    ; 

stmt 
    = 
    | @:lift_stmt
    | @:amnesia_stmt
    ;

lift_stmt::Lift 
    = 
    lift:('return' | 'break' | 'continue' | 'throw') [value:expression]
    ; 

amnesia_stmt::AmnesiaStmt
    = 
    | stmt:assigment 
    | stmt:expression 
    ; 

assigment::Assigment
    = 
    name:name '=' ~ value:expression
    ; 

expression
    = 
    | expr_op
    | term 
    ;

expr_op::Operation  
    = 
    left:term op:('+' | '-') ~ right:term 
    ;

call::Call
    = 
    name:name args:{factor}+
    ; 

term
    = 
    | term_op
    | call
    | factor 
    ; 

term_op::Operation
    =
    left:term op:('*' | '/') ~ right:factor 
    ; 

factor 
    = 
    | '(' ~ @:expression ')'
    | @:atom 
    ; 

atom 
    =
    | @:int 
    | @:var 
    ; 

var::Variable
    = 
    name:name 
    ;

name
    = 
    /[a-zA-Z_][a-zA-Z_0-9]*/
    ;

int::Integer
    = 
    value:(/\-?[0-9]+/)
    ;

newline
    =
    {['\u000C'] ['\r'] '\n'}+
    ;
